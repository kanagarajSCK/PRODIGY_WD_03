<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tic-Tac-Toe â€” Prodigy InfoTech (PRODIGY_WD_03)</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#98a0b3; --accent:#7aa2ff;
      --win:#00d1a9; --los:#ff6b6b; --glass:rgba(255,255,255,0.03);
      --radius:14px;
      font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; background:linear-gradient(180deg,#071127,#0f1724); color:#eaf0ff}
    .wrap{max-width:920px;margin:28px auto;padding:18px;display:grid;gap:18px}
    header{display:flex;justify-content:space-between;align-items:center;gap:12px}
    h1{margin:0;font-size:20px;letter-spacing:0.2px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:18px;border-radius:var(--radius);}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    select,input,button{font:inherit}
    button{
      background:var(--card); color:var(--accent); border:1px solid rgba(122,162,255,0.12); padding:10px 12px;
      border-radius:10px; cursor:pointer; font-weight:700;
    }
    button.ghost{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)}
    .board-wrap{display:flex;gap:20px;align-items:flex-start;flex-wrap:wrap}
    .board{
      width:360px;height:360px;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);
      gap:8px;padding:8px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.03);
    }
    .cell{
      background:var(--glass); display:flex;align-items:center;justify-content:center;font-size:56px;font-weight:800;
      color:#dff0ff;border-radius:8px;cursor:pointer;user-select:none;transition:transform .09s ease, background .12s;
    }
    .cell:hover{transform:translateY(-4px)}
    .cell.disabled{cursor:not-allowed;opacity:.7;transform:none}
    .meta{flex:1;min-width:220px}
    .status{font-size:14px;color:var(--muted);margin-top:6px}
    .score{display:flex;gap:12px;margin-top:12px}
    .score .box{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;min-width:90px;text-align:center}
    .win{background:linear-gradient(90deg,#0d2235,#072634);box-shadow:0 6px 18px rgba(0,0,0,0.5)}
    .highlight{background:linear-gradient(90deg, rgba(122,162,255,0.12), rgba(0,209,169,0.06));border:1px solid rgba(122,162,255,0.12)}
    .small{font-size:13px;color:var(--muted)}
    .history{max-height:180px;overflow:auto;padding:8px;border-radius:10px;background:rgba(0,0,0,0.2);margin-top:8px}
    .history .item{display:flex;justify-content:space-between;padding:6px 8px;border-radius:8px;margin-bottom:6px;background:rgba(255,255,255,0.01)}
    footer{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px;padding-top:6px}
    @media (max-width:800px){
      .board{width:320px;height:320px}
    }
    @media (max-width:620px){
      .board-wrap{flex-direction:column;align-items:center}
      .board{width:300px;height:300px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ðŸŽ® Tic-Tac-Toe â€” Prodigy InfoTech (PRODIGY_WD_03)</h1>
      <div class="small">Build: HTML â€¢ CSS â€¢ JavaScript</div>
    </header>

    <section class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div class="controls" aria-hidden="false">
          <label class="small" style="display:flex;align-items:center;gap:8px">
            Mode:
            <select id="mode">
              <option value="pvp">2-Player (Local)</option>
              <option value="pvc">1-Player (vs AI â€” Easy)</option>
              <option value="pvc-hard">1-Player (vs AI â€” Hard)</option>
            </select>
          </label>
          <label class="small" style="display:flex;align-items:center;gap:8px">
            Starting:
            <select id="startPlayer">
              <option value="X">X</option>
              <option value="O">O</option>
            </select>
          </label>
          <button id="newGame">New Game</button>
          <button id="resetScores" class="ghost">Reset Scores</button>
        </div>

        <div style="text-align:right">
          <div class="small">Controls: Click a cell to play. Reset to clear board.</div>
          <div class="small">Accessibility: keyboard navigation not required but you can tab to buttons.</div>
        </div>
      </div>
    </section>

    <section class="card board-wrap" aria-live="polite">
      <div class="board" id="board" role="grid" aria-label="Tic Tac Toe board">
        <!-- 9 cells injected by JS -->
      </div>

      <aside class="meta">
        <div class="win" style="padding:12px;border-radius:10px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <div style="font-weight:800;font-size:18px">Current Game</div>
              <div id="turnText" class="status">Ready</div>
            </div>
            <div style="text-align:right">
              <div class="small">Round</div>
              <div id="roundCount" style="font-weight:800">1</div>
            </div>
          </div>

          <div class="score" aria-hidden="false">
            <div class="box">
              <div class="small">X</div>
              <div id="scoreX" style="font-weight:800">0</div>
            </div>
            <div class="box">
              <div class="small">O</div>
              <div id="scoreO" style="font-weight:800">0</div>
            </div>
            <div class="box">
              <div class="small">Draws</div>
              <div id="scoreD" style="font-weight:800">0</div>
            </div>
          </div>

          <div class="small" style="margin-top:12px">Last games</div>
          <div class="history" id="history" aria-live="polite"></div>
        </div>
      </aside>
    </section>

    <footer>
      <div>Tip: switch mode to play vs AI.</div>
      <div>Made for <strong>Prodigy InfoTech</strong> â€” <span class="small">PRODIGY_WD_03</span></div>
    </footer>
  </div>

  <script>
    // --- Game state ---
    const boardEl = document.getElementById('board');
    const modeSelect = document.getElementById('mode');
    const startSelect = document.getElementById('startPlayer');
    const newBtn = document.getElementById('newGame');
    const resetScoresBtn = document.getElementById('resetScores');
    const turnText = document.getElementById('turnText');
    const scoreXEl = document.getElementById('scoreX');
    const scoreOEl = document.getElementById('scoreO');
    const scoreDEl = document.getElementById('scoreD');
    const historyEl = document.getElementById('history');
    const roundCountEl = document.getElementById('roundCount');

    let board = Array(9).fill(null); // null | 'X' | 'O'
    let current = 'X';
    let running = false;
    let scores = { X:0, O:0, D:0 };
    let round = 1;
    let history = []; // latest first

    // Winning combos (indexes)
    const wins = [
      [0,1,2],[3,4,5],[6,7,8],
      [0,3,6],[1,4,7],[2,5,8],
      [0,4,8],[2,4,6]
    ];

    // Initialize board DOM
    function makeBoard(){
      boardEl.innerHTML = '';
      for(let i=0;i<9;i++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.setAttribute('role','gridcell');
        cell.tabIndex = 0;
        cell.dataset.idx = i;
        cell.addEventListener('click', onCellClick);
        cell.addEventListener('keydown', (e) => {
          if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onCellClick.call(cell,e); }
        });
        boardEl.appendChild(cell);
      }
    }

    // Render board
    function render(){
      for(let i=0;i<9;i++){
        const el = boardEl.children[i];
        el.textContent = board[i] || '';
        el.classList.toggle('disabled', !!board[i] || !running);
      }
      turnText.textContent = running ? `Turn: ${current}` : 'Paused / Ready';
      scoreXEl.textContent = scores.X;
      scoreOEl.textContent = scores.O;
      scoreDEl.textContent = scores.D;
      roundCountEl.textContent = round;
      renderHistory();
    }

    function startNewGame(starting = null){
      board = Array(9).fill(null);
      current = starting || startSelect.value || 'X';
      running = true;
      // remove highlights
      Array.from(boardEl.children).forEach(c => c.classList.remove('highlight'));
      render();
      // if mode is AI and AI starts
      if(isAIMode() && current === 'O') {
        // let small delay for UX
        setTimeout(aiMove, 350);
      }
    }

    function isAIMode(){ return modeSelect.value !== 'pvp'; }

    // Click handler
    function onCellClick(e){
      if(!running) return;
      const idx = +this.dataset.idx;
      if(board[idx]) return; // occupied
      // Place
      board[idx] = current;
      // Check result
      const result = evaluate(board);
      if(result.win){
        // highlight
        result.combo.forEach(i => boardEl.children[i].classList.add('highlight'));
        running = false;
        scores[current] += 1;
        pushHistory(`${current} wins`);
      } else if(result.draw){
        running = false;
        scores.D += 1;
        pushHistory('Draw');
      } else {
        // switch player
        current = current === 'X' ? 'O' : 'X';
        // If AI turn, make AI move after short delay
        if(isAIMode() && running && current === 'O'){
          setTimeout(aiMove, 350);
        }
      }
      render();
    }

    // Evaluate board -> { win:bool, combo:[], draw:bool }
    function evaluate(b){
      for(const combo of wins){
        const [a,b1,c] = combo;
        if(board[a] && board[a] === board[b1] && board[a] === board[c]){
          return { win:true, combo };
        }
      }
      if(b.every(Boolean)) return { win:false, draw:true };
      return { win:false, draw:false };
    }

    // AI Move: two implementations:
    // - Easy: pick a random empty cell
    // - Hard: minimax for near-perfect play
    function aiMove(){
      if(!running) return;
      const mode = modeSelect.value;
      let idx;
      if(mode === 'pvc') {
        idx = aiRandom();
      } else {
        idx = aiMinimaxMove();
      }
      if(idx === undefined) return;
      board[idx] = current;
      const result = evaluate(board);
      if(result.win){
        result.combo.forEach(i => boardEl.children[i].classList.add('highlight'));
        running = false;
        scores[current] += 1;
        pushHistory(`${current} wins`);
      } else if(result.draw){
        running = false;
        scores.D += 1;
        pushHistory('Draw');
      } else {
        current = current === 'X' ? 'O' : 'X';
      }
      render();
    }

    function aiRandom(){
      const empties = board.flatMap((v,i)=> v?[]:[i]);
      if(!empties.length) return undefined;
      return empties[Math.floor(Math.random()*empties.length)];
    }

    // Minimax (returns best index for 'O' assuming 'X' is opponent)
    function aiMinimaxMove(){
      // We will run minimax from current board where current is 'O' for AI
      const player = current; // should be 'O'
      const opponent = player === 'X' ? 'O' : 'X';

      // If board empty, choose center for speed
      if(board.every(v => v===null)) return 4;

      function minimax(b, turn){
        const evalRes = evaluate(b);
        if(evalRes.win){
          // whoever last moved wins -> assign scores
          // find who is winning: check the winner from combo value
          const winner = b[evalRes.combo[0]];
          return { score: winner === player ? 10 : -10 };
        }
        if(evalRes.draw) return { score: 0 };

        const moves = [];
        for(let i=0;i<9;i++){
          if(!b[i]){
            const copy = b.slice();
            copy[i] = turn;
            const res = minimax(copy, turn === 'X' ? 'O' : 'X');
            moves.push({ idx:i, score: res.score });
          }
        }

        // choose best depending on who's turn
        if(turn === player){
          // maximize
          let best = moves[0];
          for(const m of moves) if(m.score > best.score) best = m;
          return best;
        } else {
          // minimize
          let best = moves[0];
          for(const m of moves) if(m.score < best.score) best = m;
          return best;
        }
      }

      const best = minimax(board.slice(), player);
      return best.idx;
    }

    // Save history (latest first), keep up to 10
    function pushHistory(text){
      history.unshift({ text, time: (new Date()).toLocaleTimeString() });
      if(history.length>10) history.pop();
    }

    function renderHistory(){
      historyEl.innerHTML = '';
      if(history.length===0){
        historyEl.innerHTML = '<div class="small" style="padding:8px;color:var(--muted)">No games yet</div>';
        return;
      }
      history.forEach(h=>{
        const d = document.createElement('div');
        d.className = 'item';
        d.innerHTML = `<div style="font-weight:700">${h.text}</div><div class="small">${h.time}</div>`;
        historyEl.appendChild(d);
      });
    }

    // Reset scores + history
    function resetScores(){
      scores = { X:0, O:0, D:0 };
      history = [];
      round = 1;
      render();
    }

    // New round (keep scores)
    function newRound(){
      round += 1;
      startNewGame(startSelect.value);
    }

    // Evaluate & push to history if game ended on newGame click
    function handleNewClicked(){
      // If current game ended already (running false), start new round
      if(!running){
        newRound();
        return;
      }
      // If game running and not finished, still start new game and record as aborted?
      pushHistory('New game started');
      newRound();
    }

    // Hook up UI events
    newBtn.addEventListener('click', handleNewClicked);
    resetScoresBtn.addEventListener('click', () => {
      if(confirm('Reset scores and history?')) resetScores();
    });

    modeSelect.addEventListener('change', () => {
      // Start new game when mode changes
      startNewGame(startSelect.value);
    });

    startSelect.addEventListener('change', () => {
      startNewGame(startSelect.value);
    });

    // Keyboard shortcut: N = new, R = reset scores, M = toggle mode
    window.addEventListener('keydown', (e) => {
      if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
      if(e.key.toLowerCase() === 'n'){ handleNewClicked(); }
      if(e.key.toLowerCase() === 'r'){ if(confirm('Reset scores and history?')) resetScores(); }
      if(e.key.toLowerCase() === 'm'){ // toggle modes quickly
        if(modeSelect.value === 'pvp') modeSelect.value = 'pvc';
        else if(modeSelect.value === 'pvc') modeSelect.value = 'pvc-hard';
        else modeSelect.value = 'pvp';
        startNewGame(startSelect.value);
      }
    });

    // On game end, push result to history and allow new round
    // But evaluate already pushes results when a win/draw occurs inside click/aiMove

    // Initialize
    makeBoard();
    startNewGame(startSelect.value);
    render();

    // expose for console debugging (optional)
    window._ttt = { board, scores, startNewGame, resetScores };
  </script>
</body>
</html>
